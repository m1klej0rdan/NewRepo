/*
1. Стек (Stack)

Рабочая область для функций.

Локальные переменные

Аргументы функций

Адреса возврата


Статическая память

.data - инициализированные глобальные/статические переменные с известным значением

.bss - нулевые или неинициализированные глобальные/статические переменные


 Сегмент кода (Code/Text)

Исполняемые инструкции программы.



Машинный код функций

Код методов


2. динамическая память 
это область памяти, где можно вручную выделять и освобождать память во время выполнения программы. В отличие от стека, она требует явного управления.​

Характеристика	Стек	Куча
Управление	Автоматическое	Ручное
Принцип	поочередный	Произвольный порядок
Размер	Ограниченный​	Очень большой​
Скорость	Быстро	Медленнее
Жизненный цикл	До конца функции​	До явного delete​
Фрагментация	Отсутствует	Возможна

3. Память — это линейная последовательность байтов, как огромный массив. Каждый байт имеет уникальный номер — адрес.

Адрес ячейки памяти
Это номер байта в памяти (как индекс в массиве)

Пример: 0x7ffd42a3b5c4 — шестнадцатеричное представление адреса

CPU обращается к данным по этим адресам

Указатели и адреса
Указатель — это переменная, которая хранит адрес памяти другой переменной.


4.Операторы break и continue используются для изменения стандартного хода выполнения цикла,
предоставляя  дополнительный контроль над итерациями.

Оператор break обеспечивает немедленный выход из текущего цикла
полностью прекращая его выполнение, независимо от того, достигнуто ли условие завершения цикла.
Досрочное завершение
Выход из бесконечного цикла


Оператор continue пропускает оставшуюся часть текущей итерации цикла и немедленно переходит к следующей итерации. При этом сам цикл не прерывается.
Пропуск ненужного кода
Улучшение читаемости



Переполнение ресурсов
Зависание программы

*/

#include "string_utils.h"

namespace StringUtils {

size_t string_length(const char* str) {
    size_t length = 0;
    while (str[length] != '\0') {
        length++;
    }
    return length;
}

char* string_concat(const char* str1, const char* str2) {
    size_t len1 = string_length(str1);
    size_t len2 = string_length(str2);
    char* result = new char[len1 + len2 + 1];
    for (size_t i = 0; i < len1; i++) {
        result[i] = str1[i];
    }
    for (size_t i = 0; i < len2; i++) {
        result[len1 + i] = str2[i];
    }
    result[len1 + len2] = '\0';
    return result;
}

char* string_copy(const char* str) {
    size_t len = string_length(str);
    char* copy = new char[len + 1];
    for (size_t i = 0; i <= len; i++) {
        copy[i] = str[i];
    }
    return copy;
}

void string_reverse(char* str) {
    size_t len = string_length(str);
    for (size_t i = 0; i < len / 2; i++) {
        char temp = str[i];
        str[i] = str[len - i - 1];
        str[len - i - 1] = temp;
    }
}

}